<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Earthquake Depth Visualization</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; }
    #plot { width: 100%; height: 100vh; display:flex; align-items:center; justify-content:center; }
  </style>
</head>
<body>
  <div id="plot">Loading…</div>

  <script>
    "use strict";

    // -------------------------------------------------------------------------
    // ✅ NEW — Helper to read Experience Builder selection passed as ?eb_data_s=
    // -------------------------------------------------------------------------
    function getEbQueryParam() {
      const qs = new URLSearchParams(window.location.search);
      const v = qs.get("eb_data_s");
      return v ? decodeURIComponent(v) : null;
    }

    // ---- CONFIG ----
    const SERVICE_BASE =
      "https://services.arcgis.com/acgZYxoN5Oj8pDLa/arcgis/rest/services/SC_Earthquakes_test_jmcguinn/FeatureServer/0/query";
    const DEPTH_FIELD = "depth_km";
    const MAG_FIELD   = "mag";

    // -------------------------------------------------------------------------
    // ✅ Modified parseExperienceHash()
    //    Now it first checks location.hash, and if empty,
    //    it reads ?eb_data_s= from the query string.
    // -------------------------------------------------------------------------
    function parseExperienceHash() {
      // 1) Normal reading from URL hash (iframe will often NOT have one)
      let raw = window.location.hash || "";

      // 2) If iframe has no hash, use eb_data_s query parameter from EB
      const qp = getEbQueryParam();
      if (!raw && qp) {
        raw = "#data_s=" + qp;
      }

      const out = { geometry: null, spatialRel: null };
      if (!raw.includes("data_s=")) return out;

      const decoded = decodeURIComponent(raw.slice(1)); 
      const after = decoded.split("data_s=")[1] || "";

      // ---- Parse geometry JSON ----
      const geomIdx = after.lastIndexOf("geometry:");
      if (geomIdx !== -1) {
        const jsonStart = after.indexOf("{", geomIdx);
        if (jsonStart !== -1) {
          let depth = 0, end = -1;
          for (let i = jsonStart; i < after.length; i++) {
            const ch = after[i];
            if (ch === "{") depth++;
            else if (ch === "}") {
              depth--;
              if (depth === 0) { end = i; break; }
            }
          }
          if (end !== -1) {
            try { out.geometry = JSON.parse(after.slice(jsonStart, end + 1)); } catch (_) {}
          }
        }
      }

      // ---- Parse spatialRel ----
      const relMatch = after.match(/spatialRel:[^:]+:[^,]+/g);
      if (relMatch?.length) out.spatialRel = relMatch.at(-1).split(":").pop();

      return out;
    }

    // ---- Build REST URL ----
    function buildQueryURL(geomInfo) {
      const params = new URLSearchParams({
        where: "1=1",
        outFields: "*",
        returnGeometry: "true",
        f: "geojson"
      });

      if (geomInfo?.geometry) {
        params.set("geometry", JSON.stringify(geomInfo.geometry));
        const isPolygon = !!geomInfo.geometry.rings;
        params.set("geometryType", isPolygon ? "esriGeometryPolygon" : "esriGeometryEnvelope");
        params.set("inSR", String(geomInfo.geometry.spatialReference?.wkid || 102100));
        if (geomInfo.spatialRel) params.set("spatialRel", geomInfo.spatialRel);
      }

      return `${SERVICE_BASE}?${params.toString()}`;
    }

    // ---- Fetch + Plot ----
    async function plot() {
      const mount = document.getElementById("plot");
      mount.textContent = "Loading…";

      try {
        const sel = parseExperienceHash();
        const url = buildQueryURL(sel);

        const res = await fetch(url, { mode: "cors" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();

        const feats = data.features || [];
        if (!feats.length) {
          mount.innerHTML = "No features returned. Selection may not intersect earthquakes.";
          return;
        }

        const xs = [], ys = [], zs = [], mags = [];
        for (const f of feats) {
          const coords = f.geometry?.coordinates;
          if (!Array.isArray(coords)) continue;

          const x = Number(coords[0]);
          const y = Number(coords[1]);
          const depth = Number(f.properties?.[DEPTH_FIELD] ?? 0);
          const mag   = Number(f.properties?.[MAG_FIELD]   ?? 0);

          if (!Number.isNaN(x) && !Number.isNaN(y)) {
            xs.push(x); ys.push(y); zs.push(depth); mags.push(mag);
          }
        }

        if (!xs.length) {
          mount.innerHTML = "No usable coordinates returned.";
          return;
        }

        Plotly.newPlot("plot",
          [{
            x: xs, y: ys, z: zs,
            mode: "markers",
            type: "scatter3d",
            marker: {
              size: mags.map(m => (m || 0) * 2),
              color: mags,
              opacity: 0.85,
              colorbar: { title: "Magnitude" }
            }
          }],
          {
            title: "3D Earthquake Depth Distribution",
            scene: {
              zaxis: { autorange: "reversed", title: "Depth (km)" },
              xaxis: { title: "Longitude" },
              yaxis: { title: "Latitude" }
            },
            margin: { l: 0, r: 0, t: 40, b: 0 }
          },
          { responsive: true }
        );
      } catch (err) {
        console.error(err);
        document.getElementById("plot").textContent =
          "Error loading data (see console).";
      }
    }

    // In iframe, hash won’t change — EB updates query string instead
    window.addEventListener("hashchange", plot);

    plot();
  </script>
</body>
</html>
