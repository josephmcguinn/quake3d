<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SC Earthquakes — Map + 3D Depth</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet + Leaflet Draw -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

  <style>
    :root { --sidebar: 340px; }
    html, body { height: 100%; margin: 0; font-family: system-ui, Arial, sans-serif; }
    .app {
      display: grid;
      grid-template-columns: var(--sidebar) 1fr;
      grid-template-rows: 100vh;
      gap: 0;
    }
    .panel {
      padding: 14px 16px;
      border-right: 1px solid #e5e5e5;
      display: flex; flex-direction: column; gap: 10px;
    }
    .panel h1 { font-size: 18px; margin: 0 0 8px; }
    .panel .row { display: flex; align-items: center; gap: 8px; }
    .panel label { font-size: 13px; color: #333; }
    .panel input[type="number"] { width: 80px; padding: 4px 6px; }
    .panel button {
      padding: 6px 10px; border: 1px solid #ccc; border-radius: 6px; background:#fff; cursor: pointer;
    }
    .panel button:hover { background:#f5f5f5; }
    .panel .small { font-size: 12px; color:#666; }
    .status { font-size: 12px; color:#666; margin-top: 6px; }

    .main {
      display: grid;
      grid-template-rows: 55% 45%;
      height: 100%;
    }
    #map { width: 100%; height: 100%; }
    #plot { width: 100%; height: 100%; }
    .bar {
      display:flex; align-items:center; justify-content:space-between;
      padding:6px 10px; border-top:1px solid #eee; background:#fafafa; font-size:12px; color:#444;
    }

    @media (max-width: 1100px) {
      :root { --sidebar: 280px; }
    }
    @media (max-width: 820px) {
      .app { grid-template-columns: 1fr; grid-template-rows: auto 55% 45%; }
      .panel { border-right: none; border-bottom: 1px solid #e5e5e5; }
      .main { grid-template-rows: 55vh 45vh; }
    }
  </style>
</head>
<body>
  <div class="app">

    <!-- LEFT CONTROL PANEL -->
    <aside class="panel">
      <h1>SC Earthquakes</h1>
      <div class="small">Data live from your ArcGIS Online hosted feature layer.</div>

      <div class="row">
        <label for="minMag"><strong>Min magnitude</strong></label>
        <input type="number" step="0.1" id="minMag" value="0.0">
        <button id="applyBtn">Apply</button>
      </div>

      <div class="row">
        <button id="clearBtn">Clear selection</button>
        <button id="reloadBtn" title="Reload full dataset">Reload</button>
      </div>

      <div class="small">
        On the map, use the draw tools (polygon or rectangle) to spatially filter.
      </div>

      <div class="status" id="status">Ready.</div>
      <div class="small" id="counts"></div>

      <hr style="margin:10px 0; border:none; border-top:1px solid #eee">
      <div class="small">
        <b>Tip:</b> To point at a different dataset later, change
        <code>SERVICE_URL</code>, <code>DEPTH_FIELD</code>, and <code>MAG_FIELD</code> at the top of this file.
      </div>
    </aside>

    <!-- RIGHT: MAP (top) + 3D PLOT (bottom) -->
    <section class="main">
      <div id="map"></div>
      <div>
        <div id="plot"></div>
        <div class="bar">
          <span id="selMsg">No spatial filter</span>
          <span>Depth axis is reversed (down = deeper).</span>
        </div>
      </div>
    </section>

  </div>

  <script>
    "use strict";

    /* =========================
       CONFIG — change these later if needed
       ========================= */
    // You can provide either the layer URL (without /query) OR the /query endpoint.
    const SERVICE_URL =
      "https://services.arcgis.com/acgZYxoN5Oj8pDLa/arcgis/rest/services/SC_Earthquakes_test_jmcguinn/FeatureServer/0";
    const DEPTH_FIELD = "depth_km";
    const MAG_FIELD   = "mag";
    // ========= DEM helpers (Terrain-RGB -> elevations) =========
    const MAPTILER_KEY = "YOUR_MAPTILER_KEY"; // <-- put your key here
    const TERRAIN_ZOOM = 9; // 8–10 is fine for a state-sized view
  
    // WebMercator helpers
    const tile2lon = (x, z) => (x / Math.pow(2, z)) * 360 - 180;
    const tile2lat = (y, z) => {
      const n = Math.PI - (2 * Math.PI * y) / Math.pow(2, z);
      return (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
    };
  
    // Decode Mapbox/MapTiler Terrain-RGB to meters
    function rgbToMeters(r, g, b) {
      // elevation (meters) = -10000 + (R*256*256 + G*256 + B) * 0.1
      return -10000 + (r * 256 * 256 + g * 256 + b) * 0.1;
    }
  
    // Fetch one Terrain-RGB tile and return a Float32Array of elevations + size
    async function fetchTerrainTile(z, x, y) {
      const url =
        `https://api.maptiler.com/tiles/terrain-rgb-v2/${z}/${x}/${y}.png?key=${MAPTILER_KEY}`;
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.decoding = "async";
      img.src = url;
      await img.decode();
  
      const c = document.createElement("canvas");
      c.width = img.width;
      c.height = img.height;
      const ctx = c.getContext("2d");
      ctx.drawImage(img, 0, 0);
      const { data, width, height } = ctx.getImageData(0, 0, img.width, img.height);
      const out = new Float32Array(width * height);
      for (let i = 0, p = 0; i < data.length; i += 4, p++) {
        out[p] = rgbToMeters(data[i], data[i + 1], data[i + 2]); // ignore alpha
      }
      return { elev: out, width, height };
    }
  
    // Build a DEM (lon grid, lat grid, z meters) for a bbox {minLon,minLat,maxLon,maxLat}
    async function buildDEMForBBox(bbox) {
      const z = TERRAIN_ZOOM;
  
      // tiles covering bbox
      function lon2tile(lon, z) { return Math.floor(((lon + 180) / 360) * Math.pow(2, z)); }
      function lat2tile(lat, z) {
        return Math.floor(
          ((1 - Math.log(Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)) / Math.PI) / 2) *
            Math.pow(2, z)
        );
      }
      const x0 = lon2tile(bbox.minLon, z);
      const x1 = lon2tile(bbox.maxLon, z);
      const y0 = lat2tile(bbox.maxLat, z); // note swapped for TMS math
      const y1 = lat2tile(bbox.minLat, z);
  
      // stitch tiles
      let W = 0, H = 0;
      const tiles = [];
      for (let ty = y0; ty <= y1; ty++) {
        const row = [];
        let wRow = 0, hRow = 0;
        for (let tx = x0; tx <= x1; tx++) {
          const t = await fetchTerrainTile(z, tx, ty);
          row.push(t);
          wRow += t.width;
          hRow = t.height; // all equal
        }
        tiles.push(row);
        W = wRow;
        H += hRow;
      }
  
      // compose elevation raster
      const Zm = new Float32Array(W * H);
      let yOff = 0;
      for (let r = 0; r < tiles.length; r++) {
        const row = tiles[r];
        const h = row[0].height;
        let xOff = 0;
        for (let c2 = 0; c2 < row.length; c2++) {
          const { elev, width, height } = row[c2];
          // blit row by row
          for (let yy = 0; yy < height; yy++) {
            Zm.set(elev.subarray(yy * width, (yy + 1) * width), (yOff + yy) * W + xOff);
          }
          xOff += width;
        }
        yOff += h;
      }
  
      // lon/lat grids for each pixel center
      const lonGrid = new Float32Array(W * H);
      const latGrid = new Float32Array(W * H);
      for (let yy = 0; yy < H; yy++) {
        // interpolate tile row to geo
        const yFrac = yy / H;
        const ty = y0 + yFrac * (y1 - y0 + 1);
        const latTop = tile2lat(Math.floor(ty), z);
        const latBot = tile2lat(Math.floor(ty) + 1, z);
        const latRowStart = latTop;
        const latRowEnd = latBot;
        const latRow = latRowStart + (latRowEnd - latRowStart) * (ty - Math.floor(ty));
  
        for (let xx = 0; xx < W; xx++) {
          const xFrac = xx / W;
          const tx = x0 + xFrac * (x1 - x0 + 1);
          const lonLeft = tile2lon(Math.floor(tx), z);
          const lonRight = tile2lon(Math.floor(tx) + 1, z);
          const lonCol = lonLeft + (lonRight - lonLeft) * (tx - Math.floor(tx));
  
          const idx = yy * W + xx;
          lonGrid[idx] = lonCol;
          latGrid[idx] = latRow;
        }
      }
  
      // reshape 1D arrays to 2D matrices for Plotly surface (row-major)
      function reshape(arr, rows, cols) {
        const out = new Array(rows);
        for (let r = 0; r < rows; r++) {
          out[r] = Array.from(arr.subarray(r * cols, (r + 1) * cols));
        }
        return out;
      }
  
      return {
        X: reshape(lonGrid, H, W),
        Y: reshape(latGrid, H, W),
        // convert meters to kilometers to match your depth axis units
        Zkm: reshape(Zm.map(v => v / 1000), H, W)
      };
    }
    
    /* =========================
       MAP SETUP
       ========================= */
    const map = L.map("map", { preferCanvas: true })
      .setView([34.0, -81.0], 7);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 18, attribution: "&copy; OpenStreetMap"
    }).addTo(map);

    const drawnItems = new L.FeatureGroup().addTo(map);
    const drawControl = new L.Control.Draw({
      draw: {
        marker: false, circle: false, circlemarker: false, polyline: false,
        polygon: { showArea: false, allowIntersection: false },
        rectangle: {}
      },
      edit: { featureGroup: drawnItems, edit: false, remove: true }
    });
    map.addControl(drawControl);

    // Layer for quake dots
    const quakesLayer = L.layerGroup().addTo(map);

    // UI elements
    const statusEl = document.getElementById("status");
    const countsEl = document.getElementById("counts");
    const selMsgEl = document.getElementById("selMsg");
    const minMagEl = document.getElementById("minMag");

    // Current selection + filters
    let currentGeometry = null;  // ArcGIS-style geometry (rings in [x,y] = [lon,lat])
    let currentWhere     = null;

    /* =========================
       HELPERS
       ========================= */
    function serviceQueryUrl() {
      // Accept either .../0 or .../0/query in SERVICE_URL
      return SERVICE_URL.endsWith("/query") ? SERVICE_URL : `${SERVICE_URL}/query`;
    }

    function toEsriPolygonFromLeaflet(layer) {
      // Build a polygon geometry in wkid 4326 from a Leaflet polygon/rectangle
      const latlngs = layer.getLatLngs()[0]; // first ring
      const ring = latlngs.map(ll => [Number(ll.lng), Number(ll.lat)]);
      // close ring
      if (ring.length && (ring[0][0] !== ring[ring.length-1][0] || ring[0][1] !== ring[ring.length-1][1])) {
        ring.push([ring[0][0], ring[0][1]]);
      }
      return {
        rings: [ring],
        spatialReference: { wkid: 4326 }
      };
    }

    function buildParams() {
      const params = new URLSearchParams({
        f: "geojson",
        where: currentWhere || "1=1",
        outFields: "*",
        returnGeometry: "true"
      });

      if (currentGeometry) {
        params.set("geometry", JSON.stringify(currentGeometry));
        params.set("geometryType", "esriGeometryPolygon");
        params.set("inSR", "4326");
        params.set("spatialRel", "esriSpatialRelIntersects");
      }
      return params;
    }

    function setStatus(msg)   { statusEl.textContent = msg; }
    function setCounts(n)     { countsEl.textContent = `${n.toLocaleString()} features`; }
    function setSelMessage(on){ selMsgEl.textContent = on ? "Spatial filter: polygon/rectangle" : "No spatial filter"; }

    /* =========================
       DATA FETCH + RENDER
       ========================= */
    async function fetchQuakes() {
      setStatus("Loading…");
      const url = `${serviceQueryUrl()}?${buildParams().toString()}`;

      const res = await fetch(url, { mode: "cors" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      return data.features || [];
    }

    function renderOnMap(features) {
      quakesLayer.clearLayers();
      // Use Canvas circle markers for speed
      features.forEach(f => {
        const c = f.geometry && f.geometry.coordinates;
        if (!c) return;
        const lon = +c[0], lat = +c[1];
        // marker size by magnitude (min size 3)
        const mag = Number(f.properties?.[MAG_FIELD] ?? 0);
        const r = Math.max(3, mag * 2.0);
        const dot = L.circleMarker([lat, lon], {
          radius: r,
          weight: 0.5,
          color: "#333",
          fillColor: "#cc3355",
          fillOpacity: 0.7
        });
        const depth = Number(f.properties?.[DEPTH_FIELD] ?? 0);
        dot.bindPopup(
          `<b>Magnitude:</b> ${mag}<br><b>Depth (km):</b> ${depth}<br><b>Lat/Lon:</b> ${lat.toFixed(4)}, ${lon.toFixed(4)}`
        );
        quakesLayer.addLayer(dot);
      });

      // auto-zoom
      if (features.length) {
        const latlngs = features
          .map(f => f.geometry?.coordinates)
          .filter(Boolean)
          .map(([x, y]) => [y, x]);
        const bounds = L.latLngBounds(latlngs);
        // fit, but don't zoom too far in
        map.fitBounds(bounds.pad(0.25), { maxZoom: 11 });
      }
    }

  async function renderPlot(features) {
      const xs = [], ys = [], zs = [], mags = [];
      for (const f of features) {
        const c = f.geometry?.coordinates;
        if (!c) continue;
        xs.push(+c[0]); ys.push(+c[1]);
        zs.push(Number(f.properties?.[DEPTH_FIELD] ?? 0));  // km (positive down)
        mags.push(Number(f.properties?.[MAG_FIELD]   ?? 0));
      }
  
      if (!xs.length) {
        Plotly.newPlot("plot", [], { title: "No features in view" });
        return;
      }
  
      // ---- Build bbox from features to fetch a DEM slab ----
      const minLon = Math.min(...xs), maxLon = Math.max(...xs);
      const minLat = Math.min(...ys), maxLat = Math.max(...ys);
      const pad = 0.25; // small cushion around data
      const bbox = {
        minLon: minLon - pad, maxLon: maxLon + pad,
        minLat: minLat - pad, maxLat: maxLat + pad
      };
  
      let surfaceTrace = null;
      try {
        const dem = await buildDEMForBBox(bbox);
        surfaceTrace = {
          type: "surface",
          x: dem.X, y: dem.Y, z: dem.Zkm,  // km above sea level
          opacity: 0.9,
          colorscale: "Earth",
          showscale: false,
          name: "Terrain",
          // Make it look like a 'lid' the quakes hang beneath:
          contours: { z: { show: false } }
        };
      } catch (e) {
        console.warn("Terrain surface failed, continuing without it:", e);
      }
  
      // Quake points (under the surface since z-axis is reversed)
      const quakesTrace = {
        x: xs, y: ys, z: zs,
        mode: "markers",
        type: "scatter3d",
        marker: {
          size: mags.map(m => (m || 0) * 2),
          color: mags,
          opacity: 0.88,
          colorbar: { title: "Magnitude" }
        },
        name: "Earthquakes",
        hovertemplate: "Lon: %{x}<br>Lat: %{y}<br>Depth (km): %{z}<br>Mag: %{marker.color}<extra></extra>"
      };
  
      // Compute z range: terrain (>=0 km) down to deepest quake
      const deepest = Math.max(...zs);
      const layout = {
        title: "3D Earthquake Depth",
        scene: {
          zaxis: {
            autorange: "reversed",
            title: "Depth (km)",
            range: [Math.max(0, surfaceTrace ? 5 : 0), deepest] // give a bit of headroom
          },
          xaxis: { title: "Longitude" },
          yaxis: { title: "Latitude" }
        },
        margin: { l: 0, r: 0, t: 35, b: 0 }
      };
  
      const traces = surfaceTrace ? [surfaceTrace, quakesTrace] : [quakesTrace];
      await Plotly.newPlot("plot", traces, layout, { responsive: true });
    }

    async function refresh() {
      try {
        const feats = await fetchQuakes();
        setCounts(feats.length);
        renderOnMap(feats);
        renderPlot(feats);
        setStatus("Ready.");
      } catch (e) {
        console.error(e);
        setStatus("Error fetching data — open console.");
      }
    }

    /* =========================
       INTERACTION WIRES
       ========================= */
    // Draw created
    map.on(L.Draw.Event.CREATED, e => {
      drawnItems.clearLayers();
      drawnItems.addLayer(e.layer);
      currentGeometry = toEsriPolygonFromLeaflet(e.layer);
      setSelMessage(true);
      refresh();
    });

    // Remove selection
    map.on(L.Draw.Event.DELETED, () => {
      drawnItems.clearLayers();
      currentGeometry = null;
      setSelMessage(false);
      refresh();
    });

    // Apply min magnitude
    document.getElementById("applyBtn").addEventListener("click", () => {
      const minMag = Number(minMagEl.value) || 0;
      currentWhere = `${MAG_FIELD} >= ${minMag}`;
      refresh();
    });

    document.getElementById("clearBtn").addEventListener("click", () => {
      drawnItems.clearLayers();
      currentGeometry = null;
      setSelMessage(false);
      refresh();
    });

    document.getElementById("reloadBtn").addEventListener("click", () => {
      refresh();
    });

    // Initial load
    refresh();
  </script>
</body>
</html>
