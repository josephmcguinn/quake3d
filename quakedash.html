<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SC Earthquakes — Map + 3D Depth</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet + Leaflet Draw -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

  <style>
    :root { --sidebar: 340px; }
    html, body { height: 100%; margin: 0; font-family: system-ui, Arial, sans-serif; }
    .app {
      display: grid;
      grid-template-columns: var(--sidebar) 1fr;
      grid-template-rows: 100vh;
      gap: 0;
    }
    .panel {
      padding: 14px 16px;
      border-right: 1px solid #e5e5e5;
      display: flex; flex-direction: column; gap: 10px;
    }
    .panel h1 { font-size: 18px; margin: 0 0 8px; }
    .panel .row { display: flex; align-items: center; gap: 8px; }
    .panel label { font-size: 13px; color: #333; }
    .panel input[type="number"] { width: 80px; padding: 4px 6px; }
    .panel button {
      padding: 6px 10px; border: 1px solid #ccc; border-radius: 6px; background:#fff; cursor: pointer;
    }
    .panel button:hover { background:#f5f5f5; }
    .panel .small { font-size: 12px; color:#666; }
    .status { font-size: 12px; color:#666; margin-top: 6px; }

    .main {
      display: grid;
      grid-template-rows: 55% 45%;
      height: 100%;
    }
    #map { width: 100%; height: 100%; }
    #plot { width: 100%; height: 100%; }
    .bar {
      display:flex; align-items:center; justify-content:space-between;
      padding:6px 10px; border-top:1px solid #eee; background:#fafafa; font-size:12px; color:#444;
    }

    /* bottom bar button */
    .bar button {
      padding: 4px 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background:#fff;
      cursor:pointer;
      font-size: 11px;
    }
    .bar button:hover { background:#f0f0f0; }

    @media (max-width: 1100px) {
      :root { --sidebar: 280px; }
    }
    @media (max-width: 820px) {
      .app { grid-template-columns: 1fr; grid-template-rows: auto 55% 45%; }
      .panel { border-right: none; border-bottom: 1px solid #e5e5e5; }
      .main { grid-template-rows: 55vh 45vh; }
    }
  </style>
</head>
<body>
  <div class="app">

    <!-- LEFT CONTROL PANEL -->
    <aside class="panel">
      <h1>SC Earthquakes</h1>
      <div class="small">Data live from your ArcGIS Online hosted feature layer.</div>

      <div class="row">
        <label for="minMag"><strong>Min magnitude</strong></label>
        <input type="number" step="0.1" id="minMag" value="0.0">
        <button id="applyBtn">Apply</button>
      </div>

      <div class="row">
        <button id="clearBtn">Clear selection</button>
        <button id="reloadBtn" title="Reload full dataset">Reload</button>
      </div>

      <div class="small">
        On the map, use the draw tools (polygon or rectangle) to spatially filter.
      </div>

      <div class="status" id="status">Ready.</div>
      <div class="small" id="counts"></div>

      <!-- plane orientation info -->
      <div id="planeInfo" class="small" style="margin-top:8px;color:#444;"></div>

      <hr style="margin:10px 0; border:none; border-top:1px solid #eee">
      <div class="small">
        <b>Tip:</b> To point at a different dataset later, change
        <code>SERVICE_URL</code>, <code>DEPTH_FIELD</code>, and <code>MAG_FIELD</code> at the top of this file.
      </div>
    </aside>

    <!-- RIGHT: MAP (top) + 3D PLOT (bottom) -->
    <section class="main">
      <div id="map"></div>
      <div>
        <div id="plot"></div>
        <div class="bar">
          <span id="selMsg">No spatial filter</span>
          <div style="display:flex;align-items:center;gap:8px;">
            <button id="planeBtn">Compute 3D plane</button>
            <span>Depth axis is reversed (down = deeper).</span>
          </div>
        </div>
      </div>
    </section>

  </div>

  <script>
    "use strict";

    /* =========================
       CONFIG
       ========================= */
    const SERVICE_URL =
      "https://services.arcgis.com/acgZYxoN5Oj8pDLa/arcgis/rest/services/SC_Earthquakes_Master_gdb_viewonly/FeatureServer/0";
    const DEPTH_FIELD = "depth_km";
    const MAG_FIELD   = "mag";

    // DEM helpers (MapTiler Terrain-RGB)
    const MAPTILER_KEY = "BasemapAT.terrain"; // <-- your key
    const TERRAIN_ZOOM = 9;

    const tile2lon = (x, z) => (x / Math.pow(2, z)) * 360 - 180;
    const tile2lat = (y, z) => {
      const n = Math.PI - (2 * Math.PI * y) / Math.pow(2, z);
      return (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
    };

    function rgbToMeters(r, g, b) {
      return -10000 + (r * 256 * 256 + g * 256 + b) * 0.1;
    }

    async function fetchTerrainTile(z, x, y) {
      const url =
        `https://api.maptiler.com/tiles/terrain-rgb-v2/${z}/${x}/${y}.png?key=${MAPTILER_KEY}`;
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.decoding = "async";
      img.src = url;
      await img.decode();

      const c = document.createElement("canvas");
      c.width = img.width;
      c.height = img.height;
      const ctx = c.getContext("2d");
      ctx.drawImage(img, 0, 0);
      const { data, width, height } = ctx.getImageData(0, 0, img.width, img.height);
      const out = new Float32Array(width * height);
      for (let i = 0, p = 0; i < data.length; i += 4, p++) {
        out[p] = rgbToMeters(data[i], data[i + 1], data[i + 2]);
      }
      return { elev: out, width, height };
    }

    async function buildDEMForBBox(bbox) {
      const z = TERRAIN_ZOOM;

      function lon2tile(lon, z) { return Math.floor(((lon + 180) / 360) * Math.pow(2, z)); }
      function lat2tile(lat, z) {
        return Math.floor(
          ((1 - Math.log(Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)) / Math.PI) / 2) *
            Math.pow(2, z)
        );
      }
      const x0 = lon2tile(bbox.minLon, z);
      const x1 = lon2tile(bbox.maxLon, z);
      const y0 = lat2tile(bbox.maxLat, z);
      const y1 = lat2tile(bbox.minLat, z);

      let W = 0, H = 0;
      const tiles = [];
      for (let ty = y0; ty <= y1; ty++) {
        const row = [];
        let wRow = 0, hRow = 0;
        for (let tx = x0; tx <= x1; tx++) {
          const t = await fetchTerrainTile(z, tx, ty);
          row.push(t);
          wRow += t.width;
          hRow = t.height;
        }
        tiles.push(row);
        W = wRow;
        H += hRow;
      }

      const Zm = new Float32Array(W * H);
      let yOff = 0;
      for (let r = 0; r < tiles.length; r++) {
        const row = tiles[r];
        const h = row[0].height;
        let xOff = 0;
        for (let c2 = 0; c2 < row.length; c2++) {
          const { elev, width, height } = row[c2];
          for (let yy = 0; yy < height; yy++) {
            Zm.set(elev.subarray(yy * width, (yy + 1) * width), (yOff + yy) * W + xOff);
          }
          xOff += width;
        }
        yOff += h;
      }

      const lonGrid = new Float32Array(W * H);
      const latGrid = new Float32Array(W * H);
      for (let yy = 0; yy < H; yy++) {
        const yFrac = yy / H;
        const ty = y0 + yFrac * (y1 - y0 + 1);
        const latTop = tile2lat(Math.floor(ty), z);
        const latBot = tile2lat(Math.floor(ty) + 1, z);
        const latRowStart = latTop;
        const latRowEnd = latBot;
        const latRow = latRowStart + (latRowEnd - latRowStart) * (ty - Math.floor(ty));

        for (let xx = 0; xx < W; xx++) {
          const xFrac = xx / W;
          const tx = x0 + xFrac * (x1 - x0 + 1);
          const lonLeft = tile2lon(Math.floor(tx), z);
          const lonRight = tile2lon(Math.floor(tx) + 1, z);
          const lonCol = lonLeft + (lonRight - lonLeft) * (tx - Math.floor(tx));

          const idx = yy * W + xx;
          lonGrid[idx] = lonCol;
          latGrid[idx] = latRow;
        }
      }

      function reshape(arr, rows, cols) {
        const out = new Array(rows);
        for (let r = 0; r < rows; r++) {
          out[r] = Array.from(arr.subarray(r * cols, (r + 1) * cols));
        }
        return out;
      }

      return {
        X: reshape(lonGrid, H, W),
        Y: reshape(latGrid, H, W),
        Zkm: reshape(Zm.map(v => v / 1000), H, W)
      };
    }

    /* =========================
       MAP SETUP
       ========================= */
    const map = L.map("map", { preferCanvas: true })
      .setView([34.0, -81.0], 7);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 18, attribution: "&copy; OpenStreetMap"
    }).addTo(map);

    const drawnItems = new L.FeatureGroup().addTo(map);
    const drawControl = new L.Control.Draw({
      draw: {
        marker: false, circle: false, circlemarker: false, polyline: false,
        polygon: { showArea: false, allowIntersection: false },
        rectangle: {}
      },
      edit: { featureGroup: drawnItems, edit: false, remove: true }
    });
    map.addControl(drawControl);

    const quakesLayer = L.layerGroup().addTo(map);

    const statusEl   = document.getElementById("status");
    const countsEl   = document.getElementById("counts");
    const selMsgEl   = document.getElementById("selMsg");
    const minMagEl   = document.getElementById("minMag");
    const planeBtn   = document.getElementById("planeBtn");
    const planeInfoEl = document.getElementById("planeInfo");

    let currentGeometry = null;
    let currentWhere     = null;

    // plane toggle and last fetched features
    let planeEnabled = false;
    let lastFeatures = [];

    /* =========================
       HELPERS
       ========================= */
    function serviceQueryUrl() {
      return SERVICE_URL.endsWith("/query") ? SERVICE_URL : `${SERVICE_URL}/query`;
    }

    function toEsriPolygonFromLeaflet(layer) {
      const latlngs = layer.getLatLngs()[0];
      const ring = latlngs.map(ll => [Number(ll.lng), Number(ll.lat)]);
      if (ring.length && (ring[0][0] !== ring[ring.length-1][0] || ring[0][1] !== ring[ring.length-1][1])) {
        ring.push([ring[0][0], ring[0][1]]);
      }
      return {
        rings: [ring],
        spatialReference: { wkid: 4326 }
      };
    }

    function buildParams() {
      const params = new URLSearchParams({
        f: "geojson",
        where: currentWhere || "1=1",
        outFields: "*",
        returnGeometry: "true"
      });

      if (currentGeometry) {
        params.set("geometry", JSON.stringify(currentGeometry));
        params.set("geometryType", "esriGeometryPolygon");
        params.set("inSR", "4326");
        params.set("spatialRel", "esriSpatialRelIntersects");
      }
      return params;
    }

    function setStatus(msg)   { statusEl.textContent = msg; }
    function setCounts(n)     { countsEl.textContent = `${n.toLocaleString()} features`; }
    function setSelMessage(on){ selMsgEl.textContent = on ? "Spatial filter: polygon/rectangle" : "No spatial filter"; }

    // solve 3x3 linear system
    function solve3x3(m, b) {
      const a11 = m[0][0], a12 = m[0][1], a13 = m[0][2];
      const a21 = m[1][0], a22 = m[1][1], a23 = m[1][2];
      const a31 = m[2][0], a32 = m[2][1], a33 = m[2][2];

      const det =
        a11 * (a22 * a33 - a23 * a32) -
        a12 * (a21 * a33 - a23 * a31) +
        a13 * (a21 * a32 - a22 * a31);

      if (Math.abs(det) < 1e-12) return null;

      const inv11 = (a22 * a33 - a23 * a32) / det;
      const inv12 = (a13 * a32 - a12 * a33) / det;
      const inv13 = (a12 * a23 - a13 * a22) / det;
      const inv21 = (a23 * a31 - a21 * a33) / det;
      const inv22 = (a11 * a33 - a13 * a31) / det;
      const inv23 = (a13 * a21 - a11 * a23) / det;
      const inv31 = (a21 * a32 - a22 * a31) / det;
      const inv32 = (a12 * a31 - a11 * a32) / det;
      const inv33 = (a11 * a22 - a12 * a21) / det;

      const x = inv11 * b[0] + inv12 * b[1] + inv13 * b[2];
      const y = inv21 * b[0] + inv22 * b[1] + inv23 * b[2];
      const z = inv31 * b[0] + inv32 * b[1] + inv33 * b[2];

      return [x, y, z];
    }

    // least-squares plane z = a x + b y + c
    function fitPlane(xs, ys, zs) {
      const n = xs.length;
      if (n < 3) return null;

      let Sx=0, Sy=0, Sz=0, Sxx=0, Syy=0, Sxy=0, Sxz=0, Syz=0;
      for (let i = 0; i < n; i++) {
        const x = xs[i], y = ys[i], z = zs[i];
        Sx  += x;
        Sy  += y;
        Sz  += z;
        Sxx += x * x;
        Syy += y * y;
        Sxy += x * y;
        Sxz += x * z;
        Syz += y * z;
      }

      const M = [
        [Sxx, Sxy, Sx],
        [Sxy, Syy, Sy],
        [Sx,  Sy,  n ]
      ];
      const B = [Sxz, Syz, Sz];
      const sol = solve3x3(M, B);
      if (!sol) return null;
      const [a, b, c] = sol;
      return { a, b, c };
    }

    // normal vector from plane z = a x + b y + c
    function planeNormal(a, b) {
      const nx = a, ny = b, nz = -1;
      const L = Math.sqrt(nx*nx + ny*ny + nz*nz);
      return { nx: nx/L, ny: ny/L, nz: nz/L };
    }

    // normal -> strike/dip (degrees)
    function normalToStrikeDip(nx, ny, nz) {
      const dipRad = Math.atan2(Math.sqrt(nx*nx + ny*ny), Math.abs(nz));
      const dipDeg = dipRad * 180 / Math.PI;

      // strike: rotate horizontal projection 90° clockwise
      let strikeRad = Math.atan2(nx, ny);
      let strikeDeg = strikeRad * 180 / Math.PI;
      strikeDeg = (strikeDeg + 360) % 360;

      return { strike: strikeDeg, dip: dipDeg };
    }

    // RMS misfit to plane
    function rmsMisfit(xs, ys, zs, a, b, c) {
      const n = xs.length;
      let sumSq = 0;
      for (let i = 0; i < n; i++) {
        const zhat = a*xs[i] + b*ys[i] + c;
        const diff = zs[i] - zhat;
        sumSq += diff*diff;
      }
      return Math.sqrt(sumSq / n);
    }

    /* =========================
       DATA FETCH + RENDER
       ========================= */
    async function fetchQuakes() {
      setStatus("Loading…");
      const url = `${serviceQueryUrl()}?${buildParams().toString()}`;

      const res = await fetch(url, { mode: "cors" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      return data.features || [];
    }

    function renderOnMap(features) {
      quakesLayer.clearLayers();
      features.forEach(f => {
        const c = f.geometry && f.geometry.coordinates;
        if (!c) return;
        const lon = +c[0], lat = +c[1];
        const mag = Number(f.properties?.[MAG_FIELD] ?? 0);
        const r = Math.max(3, mag * 2.0);
        const dot = L.circleMarker([lat, lon], {
          radius: r,
          weight: 0.5,
          color: "#333",
          fillColor: "#cc3355",
          fillOpacity: 0.7
        });
        const depth = Number(f.properties?.[DEPTH_FIELD] ?? 0);
        dot.bindPopup(
          `<b>Magnitude:</b> ${mag}<br><b>Depth (km):</b> ${depth}<br><b>Lat/Lon:</b> ${lat.toFixed(4)}, ${lon.toFixed(4)}`
        );
        quakesLayer.addLayer(dot);
      });

      if (features.length) {
        const latlngs = features
          .map(f => f.geometry?.coordinates)
          .filter(Boolean)
          .map(([x, y]) => [y, x]);
        const bounds = L.latLngBounds(latlngs);
        map.fitBounds(bounds.pad(0.25), { maxZoom: 11 });
      }
    }

    async function renderPlot(features) {
      const xs = [], ys = [], zs = [], mags = [];
      for (const f of features) {
        const c = f.geometry?.coordinates;
        if (!c) continue;
        xs.push(+c[0]);
        ys.push(+c[1]);
        zs.push(Number(f.properties?.[DEPTH_FIELD] ?? 0));
        mags.push(Number(f.properties?.[MAG_FIELD]   ?? 0));
      }

      if (!xs.length) {
        planeInfoEl.textContent = "";
        Plotly.newPlot("plot", [], { title: "No features in view" });
        return;
      }

      const minLon = Math.min(...xs), maxLon = Math.max(...xs);
      const minLat = Math.min(...ys), maxLat = Math.max(...ys);
      const pad = 0.25;
      const bbox = {
        minLon: minLon - pad, maxLon: maxLon + pad,
        minLat: minLat - pad, maxLat: maxLat + pad
      };

      let surfaceTrace = null;
      try {
        const dem = await buildDEMForBBox(bbox);
        surfaceTrace = {
          type: "surface",
          x: dem.X, y: dem.Y, z: dem.Zkm,
          opacity: 0.9,
          colorscale: "Earth",
          showscale: false,
          name: "Terrain",
          contours: { z: { show: false } }
        };
      } catch (e) {
        console.warn("Terrain surface failed, continuing without it:", e);
      }

      const quakesTrace = {
        x: xs, y: ys, z: zs,
        mode: "markers",
        type: "scatter3d",
        marker: {
          size: mags.map(m => (m || 0) * 2),
          color: mags,
          opacity: 0.88,
          colorbar: { title: "Magnitude" }
        },
        name: "Earthquakes",
        hovertemplate: "Lon: %{x}<br>Lat: %{y}<br>Depth (km): %{z}<br>Mag: %{marker.color}<extra></extra>"
      };

      // optional best-fit plane
      let planeTrace = null;
      let maxPlaneDepth = 0;

      if (planeEnabled) {
        const coeffs = fitPlane(xs, ys, zs);
        if (coeffs) {
          const { a, b, c } = coeffs;

          // orientation + RMS
          const { nx, ny, nz } = planeNormal(a, b);
          const { strike, dip } = normalToStrikeDip(nx, ny, nz);
          const rms = rmsMisfit(xs, ys, zs, a, b, c);

          const strikeFmt = strike.toFixed(0).padStart(3, "0");
          const dipFmt = dip.toFixed(0);
          const rmsFmt = rms.toFixed(2);

          planeInfoEl.textContent =
            `Best-fit plane: strike ${strikeFmt}°, dip ${dipFmt}° (N=${xs.length}, RMS=${rmsFmt} km)`;

          const nxg = 15, nyg = 15;
          const planeX = [], planeY = [], planeZ = [];
          const spanX = maxLon - minLon || 1;
          const spanY = maxLat - minLat || 1;

          for (let j = 0; j < nyg; j++) {
            const rowX = [], rowY = [], rowZ = [];
            const yy = minLat + (spanY * j) / (nyg - 1 || 1);
            for (let i = 0; i < nxg; i++) {
              const xx = minLon + (spanX * i) / (nxg - 1 || 1);
              const zz = a * xx + b * yy + c;
              rowX.push(xx);
              rowY.push(yy);
              rowZ.push(zz);
              if (zz > maxPlaneDepth) maxPlaneDepth = zz;
            }
            planeX.push(rowX);
            planeY.push(rowY);
            planeZ.push(rowZ);
          }

          planeTrace = {
            type: "surface",
            x: planeX,
            y: planeY,
            z: planeZ,
            opacity: 0.45,
            colorscale: "RdBu",
            showscale: false,
            name: "Best-fit plane"
          };
        } else {
          planeInfoEl.textContent = "Best-fit plane unavailable (degenerate geometry).";
        }
      } else {
        planeInfoEl.textContent = "";
      }

      const deepest = Math.max(...zs, maxPlaneDepth || 0);
      const layout = {
        title: "3D Earthquake Depth",
        scene: {
          zaxis: {
            autorange: "reversed",
            title: "Depth (km)",
            range: [0, deepest]
          },
          xaxis: { title: "Longitude" },
          yaxis: { title: "Latitude" }
        },
        margin: { l: 0, r: 0, t: 35, b: 0 }
      };

      const traces = [];
      if (surfaceTrace) traces.push(surfaceTrace);
      if (planeTrace)   traces.push(planeTrace);
      traces.push(quakesTrace);

      await Plotly.newPlot("plot", traces, layout, { responsive: true });
    }

    async function refresh() {
      try {
        const feats = await fetchQuakes();
        lastFeatures = feats;
        setCounts(feats.length);
        renderOnMap(feats);
        renderPlot(feats);
        setStatus("Ready.");
      } catch (e) {
        console.error(e);
        setStatus("Error fetching data — open console.");
      }
    }

    /* =========================
       INTERACTION WIRES
       ========================= */
    map.on(L.Draw.Event.CREATED, e => {
      drawnItems.clearLayers();
      drawnItems.addLayer(e.layer);
      currentGeometry = toEsriPolygonFromLeaflet(e.layer);
      setSelMessage(true);
      refresh();
    });

    map.on(L.Draw.Event.DELETED, () => {
      drawnItems.clearLayers();
      currentGeometry = null;
      setSelMessage(false);
      refresh();
    });

    document.getElementById("applyBtn").addEventListener("click", () => {
      const minMag = Number(minMagEl.value) || 0;
      currentWhere = `${MAG_FIELD} >= ${minMag}`;
      refresh();
    });

    document.getElementById("clearBtn").addEventListener("click", () => {
      drawnItems.clearLayers();
      currentGeometry = null;
      setSelMessage(false);
      refresh();
    });

    document.getElementById("reloadBtn").addEventListener("click", () => {
      refresh();
    });

    // plane toggle
    planeBtn.addEventListener("click", () => {
      planeEnabled = !planeEnabled;
      planeBtn.textContent = planeEnabled ? "Hide 3D plane" : "Compute 3D plane";
      if (!planeEnabled) {
        planeInfoEl.textContent = "";
      }
      if (lastFeatures && lastFeatures.length) {
        renderPlot(lastFeatures);
      }
    });

    // Initial load
    refresh();
  </script>
</body>
</html>

